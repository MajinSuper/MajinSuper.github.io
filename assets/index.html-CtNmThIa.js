import{_ as e,c as r,b as a,o as n}from"./app-KjTT_h7t.js";const s={};function o(d,t){return n(),r("div",null,[...t[0]||(t[0]=[a('<h2 id="llm-推理-内容篇" tabindex="-1"><a class="header-anchor" href="#llm-推理-内容篇"><span>LLM 推理（内容篇）</span></a></h2><h3 id="大模型稳定输出json" tabindex="-1"><a class="header-anchor" href="#大模型稳定输出json"><span>大模型稳定输出json</span></a></h3><p>好文连接：</p><ul><li><a href="https://jishuzhan.net/article/1950087025666863105" target="_blank" rel="noopener noreferrer">OpenAI结构化输出</a></li><li><a href="https://zhuanlan.zhihu.com/p/1978740200084619518" target="_blank" rel="noopener noreferrer">结构化输出:JSON Mode 与 Pydantic</a></li><li><a href="https://api-docs.deepseek.com/zh-cn/guides/json_mode" target="_blank" rel="noopener noreferrer">DeepSeek官方文档</a></li><li><a href="https://platform.openai.com/docs/guides/structured-outputs" target="_blank" rel="noopener noreferrer">OpenAI官方文档</a></li></ul><table><thead><tr><th></th><th>原理</th><th>实例</th></tr></thead><tbody><tr><td>提示工程（+In context）</td><td></td><td>输出符合Json标准的格式，字段名用引号。格式如下：<code>{“name”:“value1”,…}</code><br>示例1：<code>{&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 25}</code></td></tr><tr><td>检查温度参数</td><td>温度高(&gt;0.3)，在分布中会选非最优token<br>追求多样化、不固定，会导致格式偏差</td><td>response= client.chat.completions.create(<br> …<br> temperature=0.1<br> …<br>)</td></tr><tr><td>JSON Mode</td><td>受限解码（constrained decoding）,生成每个token时，进行语法检查（状态机）</td><td>response= client.chat.completions.create(<br> …<br> <strong><code>response_format={ &quot;type&quot;: &quot;json_object&quot; }</code></strong><br> …<br>)</td></tr><tr><td>结构化输出（chat completions api）</td><td>定义Pydantic类，自动将其转成schema</td><td><strong>from pydantic import BaseModel</strong><br><strong>class DateEvent(BaseModel):<br> name: str<br> date: str<br> person_list: list[str]</strong><br>response = <strong>client.beta.chat.completions.parse</strong>(<br> …<br> <strong>response_format= DateEvent</strong><br>)<br>response.output_parsed<br>#<em>name=&#39;科学展&#39; date=&#39;周五&#39; person_list=[&#39;小王&#39;, &#39;小李&#39;]</em></td></tr><tr><td>结构化输出（responses api）</td><td>定义Pydantic类，自动将其转成schema</td><td>response = <strong>client.reponses.parse</strong>(<br> …<br> <strong>text_format = DateEvent</strong><br>)<br>response.output_parsed<br>#<em>name=&#39;科学展&#39; date=&#39;周五&#39; person_list=[&#39;小王&#39;, &#39;小李&#39;]</em></td></tr><tr><td></td><td></td><td></td></tr><tr><td>工程上，修复和重试</td><td>使用json_repair进行修复<br>解析失败进行重新生成，重试若干次</td><td>json_repair.loads(response.final_output)<br>try-except rerun</td></tr></tbody></table><details class="hint-container details"><summary>问题1: 结构化输出和json mode有什么区别？</summary><ul><li><p><mark>json mode</mark>要求输出的符合json<mark>语法</mark>，对于是不是缺少字段，字段名称是否正确没有要求</p></li><li><p><mark>结构化输出</mark>是要求输出符合schema的<mark>语义</mark>，必须严格按照字段名、字段类型返回</p></li></ul></details><p>::: deatails 问题2：流式输出和结构化数据怎么结合？</p><ul><li>实践时，做了一些显示的约定。比如章节结构体，大纲的步骤、自检内容，只展示出步骤时，约定好在“plan_list”开始展示、在“self-check”后不再展示。</li><li>也可以使用，部分解析器（Partial Parser）</li></ul><p>:::</p><h3 id="模型输出重复" tabindex="-1"><a class="header-anchor" href="#模型输出重复"><span>模型输出重复</span></a></h3><h3 id="overthinking" tabindex="-1"><a class="header-anchor" href="#overthinking"><span>overthinking</span></a></h3>',11)])])}const l=e(s,[["render",o]]),p=JSON.parse('{"path":"/article/llm_inference_content/","title":"LLM推理_内容篇","lang":"zh-CN","frontmatter":{"title":"LLM推理_内容篇","tags":["LLM inference"],"createTime":"2025-12-10T09:44:31.000Z","permalink":"/article/llm_inference_content/"},"readingTime":{"minutes":1.68,"words":505},"git":{"createdTime":1765355997000,"updatedTime":1766380135000,"contributors":[{"name":"majinsuper","username":"majinsuper","email":"1533363937@qq.com","commits":5,"avatar":"https://avatars.githubusercontent.com/majinsuper?v=4","url":"https://github.com/majinsuper"}]},"filePathRelative":"4.LLM推理/推理_内容篇.md","headers":[],"categoryList":[{"id":"d6c073","sort":4,"name":"LLM推理"}]}');export{l as comp,p as data};
